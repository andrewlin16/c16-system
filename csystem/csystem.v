
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module csystem(

	//////////// CLOCK //////////
	CLOCK_125_p,
	CLOCK_50_B5B,
	CLOCK_50_B6A,
	CLOCK_50_B7A,
	CLOCK_50_B8A,

	//////////// LED //////////
	LEDG,
	LEDR,

	//////////// KEY //////////
	CPU_RESET_n,
	KEY,

	//////////// SW //////////
	SW,

	//////////// SEG7 //////////
	HEX0,
	HEX1,
	HEX2,
	HEX3,

	//////////// HDMI-TX //////////
	HDMI_TX_CLK,
	HDMI_TX_D,
	HDMI_TX_DE,
	HDMI_TX_HS,
	HDMI_TX_INT,
	HDMI_TX_VS,

	//////////// Audio //////////
	AUD_ADCDAT,
	AUD_ADCLRCK,
	AUD_BCLK,
	AUD_DACDAT,
	AUD_DACLRCK,
	AUD_XCK,

	//////////// I2C for Audio/HDMI-TX/Si5338/HSMC //////////
	I2C_SCL,
	I2C_SDA 
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

	//////////// CLOCK //////////
	input CLOCK_125_p;
	input CLOCK_50_B5B;
	input CLOCK_50_B6A;
	input CLOCK_50_B7A;
	input CLOCK_50_B8A;

	//////////// LED //////////
	output [7:0] LEDG;
	output [9:0] LEDR;

	//////////// KEY //////////
	input CPU_RESET_n;
	input [3:0] KEY;

	//////////// SW //////////
	input [9:0] SW;

	//////////// SEG7 //////////
	output [6:0] HEX0;
	output [6:0] HEX1;
	output [6:0] HEX2;
	output [6:0] HEX3;

	//////////// HDMI-TX //////////
	output HDMI_TX_CLK;
	output [23:0] HDMI_TX_D;
	output HDMI_TX_DE;
	output HDMI_TX_HS;
	input HDMI_TX_INT;
	output HDMI_TX_VS;

	//////////// Audio //////////
	input AUD_ADCDAT;
	inout AUD_ADCLRCK;
	inout AUD_BCLK;
	output AUD_DACDAT;
	inout AUD_DACLRCK;
	output AUD_XCK;

	//////////// I2C for Audio/HDMI-TX/Si5338/HSMC //////////
	output I2C_SCL;
	inout I2C_SDA;

//=======================================================
//  REG/WIRE declarations
//=======================================================

	// audio

	reg snd_mclk;
	reg snd_mclk_counter;
	reg snd_bclk;
	reg snd_bclk_counter;

	wire [23:0] snd_gen_sample;

	reg [23:0] snd_sample;
	reg [4:0] snd_sample_ctr;

	reg snd_pblrc;
	reg snd_pbdat;

	reg [1:0] snd_state;

	// video

	reg vid_clk;

	wire hdmi_clk;
	wire [23:0] hdmi_d;
	wire hdmi_de;
	wire hdmi_hs;
	wire hdmi_vs;

	// c16 processor

	wire snd_wen;
	wire vid_wen;
	wire [1:0] w_param;
	wire [10:0] w_index;
	wire [15:0] w_val;
	wire [33:0] debug;

//=======================================================
//  Structural coding
//=======================================================

	// audio module -- for whatever reason this has to be here. I've tried
	// taking it out into its own module several times and none of them have
	// worked.

	// audio clock dividers
	initial begin
		snd_mclk <= 0;
		snd_mclk_counter <= 0;
		snd_bclk <= 0;
		snd_bclk_counter <= 0;
	end

	always @(posedge CLOCK_50_B5B) begin
		if (snd_mclk_counter == 1) begin
			snd_mclk <= !snd_mclk;
			snd_mclk_counter <= 0;
		end else begin
			snd_mclk_counter <= snd_mclk_counter + 1;
		end
	end

	always @(posedge snd_mclk) begin
		if (snd_bclk_counter == 1) begin
			snd_bclk <= !snd_bclk;
			snd_bclk_counter <= 0;
		end else begin
			snd_bclk_counter <= snd_bclk_counter + 1;
		end
	end

	// sound generator
	sound_generator sg(CLOCK_50_B5B, CPU_RESET_n, 0, 0, 0, 0, snd_gen_sample);

	// audio state machine
	initial begin
		snd_state <= 0;
		snd_pblrc <= 1;
		snd_pbdat <= 0;
	end

	always @(negedge snd_bclk) begin
		if (snd_state == 0) begin
			snd_sample <= snd_gen_sample;
			snd_pblrc <= 0;
			snd_pbdat <= snd_sample[23];
			snd_sample_ctr <= 23;
			snd_state <= 1;
		end else if (snd_state == 1) begin
			snd_pblrc <= 0;
			snd_pbdat <= snd_sample[snd_sample_ctr];

			if (snd_sample_ctr == 0) begin
				snd_sample_ctr <= 23;
				snd_state <= 2;
			end else begin
				snd_sample_ctr <= snd_sample_ctr - 1;
				snd_state <= 1;
			end
		end else if (snd_state == 2) begin
			snd_pblrc <= 1;
			snd_pbdat <= snd_sample[snd_sample_ctr];

			if (snd_sample_ctr == 0) begin
				snd_sample_ctr <= 23;
				snd_state <= 3;
			end else begin
				snd_sample_ctr <= snd_sample_ctr - 1;
				snd_state <= 2;
			end
		end else begin
			snd_sample <= snd_gen_sample;
			snd_pblrc <= 1;
			snd_pbdat <= 0;
			snd_sample_ctr <= 23;
			snd_state <= 1;
		end
	end

	// audio outputs
	assign AUD_XCK = snd_mclk;
	assign AUD_BCLK = snd_bclk;
	assign AUD_DACDAT = snd_pbdat;
	assign AUD_DACLRCK = snd_pblrc;

	// video module
	video video_out(CLOCK_50_B5B, CPU_RESET_n, 0, 0, 0, 0, hdmi_clk, hdmi_d, hdmi_de, hdmi_hs, hdmi_vs);

	// video outputs
	assign HDMI_TX_CLK = hdmi_clk;
	assign HDMI_TX_D = hdmi_d;
	assign HDMI_TX_DE = hdmi_de;
	assign HDMI_TX_HS = hdmi_hs;
	assign HDMI_TX_VS = hdmi_vs;

	// c16 processor module
	c16 proc(CLOCK_50_B5B, CPU_RESET_n, KEY, SW, snd_wen, w_param, w_index, w_val, debug);

	// debug
	assign LEDR = debug[33:24];
	assign LEDG = debug[23:16];

	sevensegment ss3(debug[15:12], HEX3);
	sevensegment ss2(debug[11:8], HEX2);
	sevensegment ss1(debug[7:4], HEX1);
	sevensegment ss0(debug[3:0], HEX0);
endmodule
